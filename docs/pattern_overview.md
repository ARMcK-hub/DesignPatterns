# Design Pattern Overview
-----
## [Creational](/docs/creational_patterns/creational_patterns.md)
* **Abstract Factory** - *Create objects without specifying concrete classes*
* **Builder** - *Create complex objects step-by-step via same construction process*
* **Factory Method** - *Create subclass-altered/defined superclass objects*
* **Prototype** - *Create replica objects from a prototype*
* **Singleton** - *Ensure a class only has one instance*

## [Structural](/docs/structural_patterns/structural_patterns.md)
* **Adapter** - *Translate an interface to be client compatible*
* **Bridge** - *Decouple an abstraction from its implementation*
* **Composite** - *Form objects into parent-child tree structures*
* **Decorator** - *Extend functionality with wrapper classes*
* **Facade** - *Simplify complex subsystems with a unified interface*
* **Flyweight** - *Reduce object instances by sharing them through a management factory*
* **Proxy** - *Control access to an underlying object*

## [Behavioral](/docs/behavioral_patterns/behavioral_patterns.md)
* **Chain of Responsability** - *Chain functionality together by pointing to the next object in line*
* **Command** - *Parameterize commands for run-time, in-code management*
* **Interpreter** - *Interpret a language into comprehensible grammar*
* **Iterator** - *Access aggregate objects without exposing the underlying represenation*
* **Mediator** - *Reduce dependencies by restricting direct object communications to a mediator*
* **Memento** - *Restore an object later by storing it as a momento via a caregiver*
* **Observer** - *Notify multiple objects when the state of one changes*
* **State** - *Allow an object to change its class via a handler*
* **Strategy** - *Vary algorithms at runtime by making them interchangable*
* **Template Method** - *Alter pre-structured, algorithm steps via subclass overrides*
* **Vistor** - *Form new algorithms by decoupling algorithms and the objects the operate on*
