# Design Pattern Overview

## Creational
* Abstract Factory - create objects without specicying concrete classes
* Builder - create complex objects step-by-step via same construction process
* Factory Method - create subclass-altered/defined superclass objects
* Prototype - create replica objects from a prototype
* Singleton - ensure an object only has one instance

## Structural
* Adapter - translate an interface to be client compatible
* Bridge - decouple an abstraction from its implementation
* Composite - form objects into parent-child tree structures
* Decorator - extend functionality with wrapper classes
* Facade - simplify complex subsystems with a unified interface
* Flyweight - reduce object instances by sharing them through a management factory
* Proxy - control access to an underlying object

## Behavioral
* Chain of Responsability - chain functionality together by pointing to the next object in line
* Command - parameterize commands for run-time, in-code management
* Interpreter - interpret a language into comprehensible grammar
* Iterator - access aggregate objects without exposing the underlying represenation
* Mediator - reduce dependencies by restricting direct object communications to a mediator
* Memento - restore an object later by storing it as a momento via a caregiver
* Observer - notify multiple objects when the state of one changes
* State - allow an object to change its class via a handler
* Strategy - vary algorithms at runtime by making them interchangable
* Template Method - alter pre-structured, algorithm steps via subclass overrides
* Vistor - form new algorithms by decoupling algorithms and the objects the operate on
